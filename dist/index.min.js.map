{"version":3,"file":"index.min.js","sources":["../src/directives/ref.ts","../src/directives/decorator.ts","../src/directives/transition.ts","../src/directives/bind.ts","../src/directives/capture.ts","../src/directives/once.ts","../src/directives/passive.ts","../src/directives/prevent.ts","../src/directives/stop.ts","../src/directives/self.ts","../src/index.ts","../src/directives/call.ts","../src/directives/each.ts"],"sourcesContent":["import { directive } from 'lit-html';\n\nexport const ref = directive((fn) => (part) => fn(part.element));","import { directive } from 'lit-html';\n\nconst decorators = new WeakMap();\n\nexport const decorator = directive((handler, ...state) => {\n    const self = (part) => {\n        const el = part.element;\n\n        if (decorators.has(part)) {\n            const [decorator, prevHandler] = decorators.get(part);\n            if (prevHandler !== handler) {\n                decorator.destroy();\n                decorators.delete(part);\n                self(part);\n            } else {\n                decorator.update(...state);\n            }\n        } else {\n            const decorator = handler(el, ...state);\n            decorators.set(part, [decorator, handler]);\n            // decorator.destroy() + decorators.delete(part) ???\n            // https://github.com/Polymer/lit-html/issues/283\n            // wait till lit-html 2 ?\n        }\n    };\n    return self;\n});\n","import { directive } from 'lit-html';\n\nexport const transition = directive((fn) => (part) => {\n\n});","import { directive, EventPart } from 'lit-html';\n\n// check this later: https://codesandbox.io/s/hyperactiv-tests-works-u47wt?file=/src/bind.js\n\ntype HTMLConrolElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | HTMLButtonElement;\n\nexport const bind = directive((handleEvent) => (part) => {\n    if (!(part instanceof EventPart)) {\n        throw new Error('\"bind\" directive can only be used in event listeners');\n    }\n\n    const el: any = part.element as HTMLConrolElement;\n    const isInput = el instanceof HTMLInputElement;\n    const isSelect = el instanceof HTMLSelectElement;\n    const isTextarea = el instanceof HTMLTextAreaElement;\n    const isButton = el instanceof HTMLButtonElement;\n\n    if (!isInput && !isSelect && !isTextarea && !isButton) {\n        throw new Error(\n            '\"bind\" directive can only be applied to input/select/textarea/button elements.'\n        );\n    }\n\n    part.setValue(function (...args) {\n        let value: string | boolean | any = el.defaultValue;\n        if (isSelect && el.options.length > 0) {\n            const i = el.selectedIndex >= 0 ? el.selectedIndex : 0;\n            value = el.options[i].value;\n        } else if (isInput) {\n            switch (el.type) {\n                case 'number':\n                case 'range':\n                    value = el.valueAsNumber;\n                    break;\n                case 'checkbox':\n                case 'radio':\n                    value = !!el.checked;\n                    break;\n                case 'time':\n                case 'date':\n                case 'datetime':\n                case 'datetime-local':\n                    value = el.valueAsDate;\n                    break;\n                default:\n                    value = el.value;\n            }\n        } else {\n            value = el.value;\n        }\n\n        handleEvent.call(this, value, ...args);\n    });\n});\n","import { directive, EventPart } from 'lit-html';\n\nexport const capture = directive((handleEvent) => (part) => {\n\n    if (!(part instanceof EventPart)) {\n        throw new Error('\"capture\" directive can only be used in event listeners');\n    }\n\n    part.setValue({ handleEvent, capture: true });\n});","import { directive, EventPart } from 'lit-html';\n\nexport const once = directive((handleEvent) => (part) => {\n\n    if (!(part instanceof EventPart)) {\n        throw new Error('\"once\" directive can only be used in event listeners');\n    }\n\n    part.setValue({ handleEvent, once: true });\n});\n","import { directive, EventPart } from 'lit-html';\n\nexport const passive = directive((handleEvent) => (part) => {\n\n    if (!(part instanceof EventPart)) {\n        throw new Error('\"passive\" directive can only be used in event listeners');\n    }\n\n    part.setValue({ handleEvent, passive: true });\n});","import { directive, EventPart } from 'lit-html';\n\nexport const prevent = directive((handleEvent) => (part) => {\n\n    if (!(part instanceof EventPart)) {\n        throw new Error('\"prevent\" directive can only be used in event listeners');\n    }\n\n    part.setValue(function (event) {\n        event.preventDefault();\n        handleEvent.call(this, event);\n    });\n});","import { directive, EventPart } from 'lit-html';\n\nexport const stop = directive((handleEvent, immediate = false) => (part) => {\n\n    if (!(part instanceof EventPart)) {\n        throw new Error('\"stop\" directive can only be used in event listeners');\n    }\n\n    part.setValue(function (event) {\n        immediate ? event.stopImmediatePropagation() : event.stopPropagation();\n        handleEvent.call(this, event);\n    });\n});","import { directive, EventPart } from 'lit-html';\n\nexport const self = directive((handleEvent) => (part) => {\n\n    if (!(part instanceof EventPart)) {\n        throw new Error('\"self\" directive can only be used in event listeners');\n    }\n\n    part.setValue(function (event) {\n        (event.target === this) && handleEvent.call(this, event);\n    });\n});","import hr from 'hyperactiv';\nimport { render, nothing } from 'lit-html';\n\nimport type * as Type from './types';\n\nconst { observe, computed, dispose } = hr;\n\nexport * from './types';\nexport * from './directives';\nexport * from 'lit-html';\n\nexport { observe, computed, dispose };\n\nexport const $ = (\n    {\n        render: template = () => nothing,\n        state: getState = {},\n        target = document.body,\n        ...options\n    }: Type.Config,\n    ...context\n): Type.Widget => {\n    const plainState = (typeof getState === 'function') ? getState(...context) : getState;\n\n    Object.entries(target.dataset).forEach(([key, value]) => {\n        if (key in plainState) plainState[key] = attrToType(value);\n    });\n\n    const state: Type.ReactiveState = observe(plainState, {\n        batch: true,\n        deep: true,\n        bind: true,\n        ...options\n    });\n\n    const emit = (name, detail, { bubbles = false, cancelable = true } = {}) => {\n        target.dispatchEvent(\n            new CustomEvent(name, { detail, bubbles, cancelable })\n        );\n    };\n\n    let mounted = false;\n    const rerender = () => {\n        render(template(state, emit, ...context), target);\n        if (!mounted) {\n            emit('mount', plainState);\n            mounted = true;\n        }\n        emit('update', plainState);\n    };\n    const renderer = computed(({ computeAsync }) => {\n        if (mounted && !document.contains(target)) return destroy();\n        return Promise.resolve().then(() => computeAsync(rerender));\n    });\n\n    const events = new Set();\n    const on = (...args: [string, () => any]) => {\n        target.addEventListener(...args);\n        const off = () => {\n            target.removeEventListener(...args);\n            return events.delete(off);\n        };\n        events.add(off);\n        return off;\n    };\n\n    const effects = new Set();\n    const effect = (...args: any[]) => {\n        const handle = computed(...args);\n        const cancel = () => {\n            dispose(handle);\n            return effects.delete(cancel);\n        };\n        effects.add(cancel);\n        return cancel;\n    };\n\n    const targetObserver = new MutationObserver((mutations: MutationRecord[]) => {\n        mutations.forEach((mutation) => {\n            if (mutation.type !== 'attributes') return;\n\n            const el: Element = mutation.target as Element;\n            const key = mutation.attributeName.replace('data-', '')\n                .replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n            if (!(key in state)) return;\n\n            const value = el.getAttribute(mutation.attributeName);\n            if (value !== mutation.oldValue) {\n                const val = attrToType(value);\n                if (state[key] !== val) state[key] = val;\n            }\n        });\n    });\n\n    targetObserver.observe(target, {\n        attributeFilter: Object.entries(plainState).reduce((attrs, [key, val]) => {\n            if (typeof val !== 'function') {\n                attrs.push(\n                    `data-${key.replace(/[A-Z]/g, (m) => '-' + m.toLowerCase())}`\n                );\n            }\n            return attrs;\n        }, []),\n        attributeOldValue: true,\n        characterData: false,\n        childList: false,\n        subtree: false\n    });\n\n    const destroy = () => {\n        emit('destroy', plainState);\n        targetObserver.disconnect();\n        dispose(renderer);\n        effects.forEach((cancel: () => any) => cancel());\n        effects.clear();\n        events.forEach((off: () => any) => off());\n        events.clear();\n        target.innerHTML = ''; // is this the best way to clean up the DOM?\n    };\n\n    const ctx = (fn: (...ctx: any[]) => any) => fn(...context);\n\n    return {\n        on,\n        ctx,\n        state,\n        effect,\n        target,\n        destroy,\n        render: rerender\n    };\n};\n\nexport const $$ = ({ target, ...config }: Type.Configs, ...context): Type.Widgets => {\n    if (!(target as NodeList | Node[]).length) {\n        target = [target] as Node[];\n    }\n\n    const widgets = Array.prototype.map.call(target, (target: HTMLElement) => {\n        return $({ ...config, target } as Type.Config, ...context);\n    });\n\n    return {\n        ...widgets,\n        effect: (...args) => widgets.map(widget => widget.effect(...args)),\n        on: (...args) => widgets.map(widget => widget.on(...args)),\n        destroy: () => widgets.forEach(widget => widget.destroy()),\n        render: () => widgets.forEach(widget => widget.render()),\n        state: fn => widgets.forEach(widget => fn(widget.state)),\n        ctx: (fn: (...ctx: any[]) => any) => fn(...context),\n        forEach: Array.prototype.forEach.bind(widgets),\n        target\n    };\n};\n\nexport const noop = () => { };\n\nexport const tick = (fn = noop) => new Promise((resolve) => setTimeout(resolve)).then(fn);\n\nexport function attrToType(val) {\n    if (val === 'true' || val === 'false') {\n        return val === 'true';\n    } else if (val === 'null') {\n        return null;\n    } else if (val === 'undefined') {\n        return undefined;\n    } else if (val !== '' && !isNaN(Number(val))) {\n        return Number(val);\n    } else {\n        try {\n            val = JSON.parse(val);\n        } catch (e) { }\n    }\n    return val;\n}\n","export const call = (handleEvent, ...args) => function (...argv) {\n    handleEvent.call(this, ...argv, ...args);\n};","import { repeat } from 'lit-html/directives/repeat';\n\nexport const each = (items, template, keyFn = (item) => item) =>\n    repeat(items, keyFn, template);\n"],"names":["ref","directive","fn","part","element","decorators","WeakMap","decorator","handler","state","self","el","has","prevHandler","get","destroy","delete","update","set","transition","bind","handleEvent","EventPart","Error","isInput","HTMLInputElement","isSelect","HTMLSelectElement","isTextarea","HTMLTextAreaElement","isButton","HTMLButtonElement","setValue","args","value","defaultValue","options","length","i","selectedIndex","type","valueAsNumber","checked","valueAsDate","call","this","capture","once","passive","prevent","event","preventDefault","stop","immediate","stopImmediatePropagation","stopPropagation","target","observe","computed","dispose","hr","$","_a","context","render","template","nothing","getState","document","body","plainState","Object","entries","dataset","forEach","key","attrToType","batch","deep","emit","name","detail","bubbles","cancelable","dispatchEvent","CustomEvent","mounted","rerender","renderer","computeAsync","contains","Promise","resolve","then","events","Set","effects","targetObserver","MutationObserver","mutations","mutation","attributeName","replace","_","w","toUpperCase","getAttribute","oldValue","val","attributeFilter","reduce","attrs","push","m","toLowerCase","attributeOldValue","characterData","childList","subtree","disconnect","cancel","clear","off","innerHTML","on","addEventListener","removeEventListener","add","ctx","effect","handle","noop","isNaN","Number","JSON","parse","e","config","widgets","Array","prototype","map","widget","argv","items","keyFn","item","repeat","setTimeout"],"mappings":"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"}